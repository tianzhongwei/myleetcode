# 1 思想
数组中，若任意一个元素 `key`，如果位于 `key` 左侧的元素都比 `key` 小，右侧的元素都比 `key` 大，则这个数组是单调递增的。
# 2 `partition` 函数：左右双指针填坑算法
1) 将参照元素(默认为数组首元素)从原数组中取出来，保存在变量 `key` 中，这样数组中最左边的第一个元素就成了一个空缺的坑位 `l`
2) 右指针 `r` 从数组尾部逆向寻找第一个小于 `key` 的元素，找到后将它取出来，填在坑 `l` 处，这时右侧就出现了一个坑位 `r`
3) 左指针 `l` 从数组头部正向查找第一个大于 `key` 的元素，找到后将它取出来，填在坑 `r` 处，这时左侧就出现了一个坑位 `l`
4) 重复上述过程，直到 `l == r`
5) 后处理：最后将 `key` 填入坑中

```C++
int partition(vector<int>& A,int l,int r) {
    int key = A[l];
    while(l < r) {
        while(l < r && A[r] >= key) r--;
        A[l] = A[r];
        while(l < r && A[l] <= key) l++;
        A[r] = A[l];
    }
    A[l] = key;     // 后处理：key 回填入交点
    return l;
}
```
# 3 分治法：分别对子数组划分
一次 `partition` 操作只是将数组分成了大于 `key` 和小于 `key` 的两部分，并不能保证整个数组有序。    
接下来，分别对这两部分进行 `partition` 划分，递归进行。
```C++
void quickSort(vector<int>& A,int l,int r) {
    if(l >= r)  return ;

    int mid = partition(A,l,r);

    quickSort(A,l,mid - 1);
    quickSort(A,mid + 1,r);
}
```
# 4 调用函数
```C++
void q_sort(vector<int>& A) {
    int l = 0;
    int r = A.size() - 1;
    quickSort(A,l,r);
}
```
# 5 复杂度分析
## 5.1 时间复杂度
### 5.1.1 一次 partition 的时间复杂度    
每次对整个数组进行一次 `partition` 需要遍历数组的所有元素，因此一次 `partition` 的时间复杂度为$O(n)$。
### 5.1.2 $partition$ 的次数：取决于参照元素 key 的选择
1) 最好的情况：每次选择的 `key` 都将当前数组划分为两等份，这样就只需要进行$log(n)$ 次划分，快排的时间复杂度为 $O(nlogn)$
2) 最坏的情况：每次选择的 `key` 都是当前序列中的最值元素，这使得每次划分后得到的两部分数组总有一部分为空，另一部分的长度为 $n - 1$，因此这样就需要进行 n 次划分，快排的时间复杂度为 $n^2$
3) 平均复杂度：$O(nlogn)$
## 5.2 空间复杂度
1) 每次 `partition` 只需要 $O(1)$ 的额外空间
2) 整个排序过程是递归进行的，需要开辟一个堆栈空间来实现递归
   1) 最好的情况：对应于时间复杂度为 $O(nlogn)$ 时，递归的最大深度为 $logn$
   2) 最坏的情况：对应于时间复杂度为 $O(n^2)$ 时，递归的最大深度为 $n$
   3) 平均空间复杂度：$O(nlogn)$


























